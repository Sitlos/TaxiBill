#### 项目总体思路流程

#### Java版本:
  
  1.用到了策略模式，简单工厂模式，单例模式
  
  2.FeeRule为规则类，其子类采用单例模式,可以看作策略类
  
  3.通过get，set来保证数据的封装性，提高安全性和灵活性
  
  4.另外，如果要对现在的规则进行拓展{
  
  		可分为以下情况:
		
  			FeeRule的拓展性:和Taxi合成复用，主要是用于扩展一些客观存在的实体规则。
			
 		   	BillStrategy的拓展性:Taxi针对白天黑天等不同情况情况选择不同的策略来计算价格，建立策略工厂选择，Taxi为
			策略的具体执行对象，也是一个合成复用的过程。
  }		
  
  5.如果要更改调整数值，可直接在RulesInfo中修改（程序中的计算全部通过这些静态变量传递的四则运算实现）,有很强的灵活性
  
  6.对策略和规则采用单例模式，一定程度上降低内存的消耗，符合OO思想的内涵。
  
  7.BillTestCase通过JUnit5用14组数据针对不同的情况对程序进行测试，确保程序的正确性

#### C++版本:
  
  1.总体采用工厂模式,单例模式来实现程序
  
  2.FeeRule为规则类，通过GetInformation类模拟从数据库中读取信息，来实现rule的初始化，有比较强的灵活性
  
  3.通过get，set来保证数据的封装性，提高安全性和灵活性
  
  4.另外，如果要对现在的规则进行拓展{
  
  		可分为三种:
		
  			FeeRule的拓展性:这个规则主要针对于一些实体类上的拓展,例如滴滴打车中有专车，快车，出租车等分类
  			，可以采用不同类型的FeeRule的派生类来实现不同类型车辆的规则建立，并且由于相同派生类的对象都是
  			一样的，因此可以采用单例模式来节约内存空间，提高效率。
			
  		   	Bill工厂的拓展性:这个规则主要针对于一些自然条件引起的拓展，比如早上，晚上，高峰期等。与上面相
  			同扩展出的工厂类通过单例模式来实现。
			
  			Taxi的拓展性:对于一些对所有情况都采用相同方式计算的功能可以采用更改其中的extra函数来实现
  			(由于这一部分比较简单，经过考虑没有采用继承的方式)
  			例如等待时间计算费用，或者实际中滴滴打车中的加钱功能等。
  }	
  
  通过上述三种方式的配合拓展，程序不光呈现出非常好的拓展性，还有非常清晰的模型,使得代码具有高度可读性
  
  5.如果要更改调整数值，可直接在RulesInfo中修改（程序中的计算全部通过这些静态变量传递的四则运算实现）,有很强的灵活性
  
  6.实现Bill接口的DaytimeBill类和NightBill类和FeeRule子类会被频繁创建和调用，因此使用单例模式来减小内存的消耗并加速
  
  7.BillTestCase通过14组单元测试数据针对不同的情况对程序进行测试，确保程序的正确性

  



